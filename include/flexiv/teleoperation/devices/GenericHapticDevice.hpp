#ifndef TELEOPERATION_GENERICHAPTICDEVICE_HPP
#define TELEOPERATION_GENERICHAPTICDEVICE_HPP

#include <chrono>
#include <memory>

#include "eigen3/Eigen/Dense"
#include "flexiv/teleoperation/devices/GenericDevice.hpp"

namespace flexiv {
namespace teleoperation {

//------------------------------------------------------------------------------
// GENERAL CONSTANTS
//------------------------------------------------------------------------------
//! Size of buffer.
const int DEVICE_HISTORY_SIZE = 200; // [number of samples]

//! Smallest time interval between two position/status reads from a haptic
//! device.
const double DEVICE_MIN_ACQUISITION_TIME = 0.0001; // [s]

//! Maximum number of joint of a haptic device.
const int C_MAX_DOF = 16;

enum HapticDeviceModel
{
  HAPTIC_DEVICE_SPACEMOUSE,
  HAPTIC_DEVICE_OMEGA_3,
  HAPTIC_DEVICE_OMEGA_6,
  HAPTIC_DEVICE_DELTA_3,
  HAPTIC_DEVICE_DELTA_6,
  HAPTIC_DEVICE_OMEGA_7,
  HAPTIC_DEVICE_SIGMA_6P,
  HAPTIC_DEVICE_SIGMA_7,
  HAPTIC_DEVICE_FALCON,
  HAPTIC_DEVICE_MPR,
  HAPTIC_DEVICE_XTH_1,
  HAPTIC_DEVICE_XTH_2,
  HAPTIC_DEVICE_KSD_1,
  HAPTIC_DEVICE_VIC_1
};

struct TimestampValue
{
  //! Time in seconds when value data was acquired.
  double m_time;

  //! Value data.
  double m_value;
};

struct TimestampPos
{
  //! Time in seconds when position data was acquired.
  double m_time;

  //! Position data.
  Eigen::Vector3d m_pos;
};

struct TimestampRot
{
  //! Time in seconds when rotation matrix data data was acquired.
  double m_time;

  //! Rotation matrix data.
  Eigen::Matrix3d m_rot;
};

struct HapticDeviceInfo
{
  //* Haptic device model. */
  HapticDeviceModel m_model;

  //* Name of the haptic device model. */
  std::string m_modelName;

  //* Name of the haptic device manufacturer. */
  std::string m_manufacturerName;

  //* Maximum continuous force in [N] that can be generated by the haptic
  // device
  // in translation. */
  double m_maxLinearForce;

  //* Maximum continuous torque in [N*m] that can be generated by the haptic
  // device in orientation. */
  double m_maxAngularTorque;

  //* Maximum continuous force in [N] that can be produced by the haptic
  // gripper. */
  double m_maxGripperForce;

  //* Maximum recommended linear damping factor Kv when using the
  // getVelocity()
  // method from the device class. */
  double m_maxLinearDamping;

  //* Maximum recommended angular damping factor Kv when using the
  // getAngularVelocity() method from the device class. */
  double m_maxAngularDamping;

  //* Maximum recommended angular damping factor Kv when using the
  // getGripperAngularVelocity() method from the device class. */
  double m_maxGripperAngularDamping;

  //* Radius which describes the largest sphere (3D devices) or circle (2D
  // Devices) which can be enclosed inside the physical workspace of the
  // device.
  // */
  double m_workspaceRadius;

  //* Maximum open angle of the gripper [rad]. */
  double m_gripperMaxAngleRad;

  //* If __true__ then device supports position sensing (x,y,z axis),
  //__false__
  //  otherwise. */
  bool m_sensedPosition;

  //* If __true__ then device supports rotation sensing. (i.e stylus, pen),
  //  __false__ otherwise. */
  bool m_sensedRotation;

  //* If __true__ then device supports a sensed gripper interface, __false__
  //  otherwise. */
  bool m_sensedGripper;

  //* If __true__ then device provides actuation capabilities for translation
  //  degrees of freedom (x,y,z axis), __false__ otherwise. */
  bool m_actuatedPosition;

  //* If __true__ then device provides actuation capabilities for orientation
  //  degrees of freedom (i.e stylus, wrist, pen), __false__ otherwise. */
  bool m_actuatedRotation;

  //* If __true__ then device provides an actuated gripper, __false__
  // otherwise.
  //*/
  bool m_actuatedGripper;

  //* If __true__ then the device can be used for left hands, __false__
  //  otherwise. */
  bool m_leftHand;

  //* If __true__ then the device can be used for right hands, __false__
  // otherwise. */
  bool m_rightHand;
};

class GenericHapticDevice;
typedef std::shared_ptr<GenericHapticDevice> GenericHapticDevicePtr;

class GenericHapticDevice : public GenericDevice
{

public:
  GenericHapticDevice(unsigned int a_deviceNumber = 0);
  virtual ~GenericHapticDevice() { };

  static GenericHapticDevicePtr create(unsigned int a_deviceNumber = 0)
  {
    (void)a_deviceNumber;
    return (std::make_shared<GenericHapticDevice>(a_deviceNumber));
  }

public:
  //! This method opens a connection to the haptic device.
  virtual bool open() { return (false); }

  //! This method closes the connection to the haptic device.
  virtual bool close() { return (false); }

  //! This method calibrates the haptic device.
  virtual bool calibrate(bool a_forceCalibration = false)
  {
    (void)a_forceCalibration;
    return m_deviceReady;
  }

  //! This method returns the position of the haptic device.
  virtual bool getPosition(Eigen::Vector3d& a_position)
  {
    a_position.setZero();
    return (m_deviceReady);
  }

  //! This method returns the linear velocity of the haptic device.
  virtual bool getLinearVelocity(Eigen::Ref<Eigen::Vector3d> a_linearVelocity)
  {
    a_linearVelocity = m_linearVelocity;
    return (m_deviceReady);
  }

  //! This method returns the orientation frame of the haptic device
  //! end-effector.
  virtual bool getRotation(Eigen::Matrix3d& a_rotation)
  {
    a_rotation.setIdentity();
    return (m_deviceReady);
  }

  //! This method returns the joint angles of the haptic device.
  virtual bool getJointAnglesRad(double a_jointAnglesRad[C_MAX_DOF])
  {
    (void)a_jointAnglesRad;
    return (false);
  }

  //! This method returns the angular velocity of haptic device.
  virtual bool getAngularVelocity(Eigen::Ref<Eigen::Vector3d> a_angularVelocity)
  {
    a_angularVelocity = m_angularVelocity;
    return (m_deviceReady);
  }

  //! This method returns the position and orientation of the haptic device
  //! through a transformation matrix.
  virtual bool getTransform(Eigen::Matrix4d& a_transform);

  //! This method returns the gripper angle in radian [rad].
  virtual bool getGripperAngleRad(double& a_angle);

  //! This method returns the gripper angle in degrees [deg].
  inline bool getGripperAngleDeg(double& a_angle)
  {
    double angle;
    bool result = getGripperAngleRad(angle);
    a_angle = (angle) / M_PI * 180.0;
    return (result);
  }

  //! This method returns the angular velocity of the gripper. Units are in
  //! radians per second [rad/s].
  virtual bool getGripperAngularVelocity(double& a_gripperAngularVelocity)
  {
    a_gripperAngularVelocity = m_gripperAngularVelocity;
    return (m_deviceReady);
  }

  //! This method returns the sensed force [N] from the haptic device.
  virtual bool getForce(Eigen::Vector3d& a_force)
  {
    a_force = m_prevForce;
    return (m_deviceReady);
  }

  //! This method returns the sensed torque [N*m] from the haptic device.
  virtual bool getTorque(Eigen::Vector3d& a_torque)
  {
    a_torque = m_prevTorque;
    return (m_deviceReady);
  }

  //! This method returns the sensed torque [N*m] from the force gripper.
  virtual bool getGripperForce(double& a_gripperForce)
  {
    a_gripperForce = m_prevGripperForce;
    return (m_deviceReady);
  }

  //! This method returns the status of a selected user switch [__true__ =
  //! __ON__ / __false__ = __OFF__].
  virtual bool getUserSwitch(int a_switchIndex, bool& a_status);

  //! This method returns the status of all user switches [__true__ = __ON__ /
  //! __false__ = __OFF__].
  virtual bool getUserSwitches(unsigned int& a_userSwitches)
  {
    a_userSwitches = 0;
    return (m_deviceReady);
  }

  //! This method returns the technical specifications of this haptic device.
  HapticDeviceInfo getSpecifications() { return (m_specifications); }

  //! This method enables or disables the virtual gripper switch.
  virtual void setEnableGripperUserSwitch(const bool a_status)
  {
    m_gripperUserSwitchEnabled = a_status;
  }

  //! This method returns the status of the virtual gripper user switch. If
  //! __true__, then gripper is used to emulate a user switch. Return
  //! __false__ otherwise.
  virtual bool getEnableGripperUserSwitch() const { return (m_gripperUserSwitchEnabled); }

  //! This method sends a force [N] command to the haptic device.
  bool setForce(const Eigen::Vector3d& a_force)
  {
    return (setForceAndTorqueAndGripperForce(a_force, Eigen::Vector3d(0.0, 0.0, 0.0), 0.0));
  }

  //! This method sends a force [N] and torque [N*m] command to the haptic
  //! device.
  bool setForceAndTorque(const Eigen::Vector3d& a_force, const Eigen::Vector3d& a_torque)
  {
    return (setForceAndTorqueAndGripperForce(a_force, a_torque, 0.0));
  }

  //! This method sends a force [N], torque [N*m], and gripper force [N]
  //! command to the haptic device.
  virtual bool setForceAndTorqueAndGripperForce(
      const Eigen::Vector3d& a_force, const Eigen::Vector3d& a_torque, double a_gripperForce)
  {
    (void)a_force;
    (void)a_torque;
    (void)a_gripperForce;
    return (m_deviceReady);
  }

public:
  //! This method returns the number of haptic devices available for this
  //! class of devices.
  static unsigned int getNumDevices() { return (0); }

public:
  //! Technical specifications of haptic device.
  HapticDeviceInfo m_specifications;

protected:
  /** Last force sent to haptic device */
  Eigen::Vector3d m_prevForce;

  /** Last torque sent to haptic device */
  Eigen::Vector3d m_prevTorque;

  /** Last gripper force sent to haptic device */
  double m_prevGripperForce;

  /** Last estimated linear velocity */
  Eigen::Vector3d m_linearVelocity;

  /** Last estimated angular velocity */
  Eigen::Vector3d m_angularVelocity;

  /** Last estimated gripper angular velocity */
  double m_gripperAngularVelocity;

protected:
  /** History position data of the device. */
  TimestampPos m_historyPos[DEVICE_HISTORY_SIZE];

  /** History orientation data of the device. */
  TimestampRot m_historyRot[DEVICE_HISTORY_SIZE];

  /** History position of device gripper. */
  TimestampValue m_historyGripper[DEVICE_HISTORY_SIZE];

  /** Current index position in history data table. */
  int m_indexHistoryPos;

  /** Current index position in history data table. */
  int m_indexHistoryRot;

  /** Current index position in history data table. */
  int m_indexHistoryGripper;

  /** Last index position used to compute velocity. */
  int m_indexHistoryPosWin;

  /** Last index position used to compute velocity. */
  int m_indexHistoryRotWin;

  /** Last index position used to compute velocity. */
  int m_indexHistoryGripperWin;

  /** Window time interval for measuring linear velocity. */
  double m_linearVelocityWindowSize;

  /** Window time interval for measuring angular velocity. */
  double m_angularVelocityWindowSize;

  /** Window time interval for measuring gripper velocity. */
  double m_gripperVelocityWindowSize;

  /** General clock used to compute velocity signals. */
  std::chrono::_V2::system_clock::time_point m_tpStart;

protected:
  /** If __true__ then virtual gripper user switch is enabled. */
  bool m_gripperUserSwitchEnabled;

  /** Position of the gripper when the user encounters the virtual switch. */
  double m_gripperUserSwitchAngleStart;

  /** Position of the gripper when the virtual switch is enabled and the
   * "click" occurs. */
  double m_gripperUserSwitchAngleClick;

  /** Maximum force level at the force gripper when the "click" occurs. */
  double m_gripperUserSwitchForceClick;

  /** Force level when the gripper is completely closed after the "click"
   * event has occurred. */
  double m_gripperUserSwitchForceEngaged;

protected:
  //* Virtual gripper current angle in radians [rad]. */
  double m_virtualGripperAngle;

  //* Virtual gripper minimum angle in radians [rad]. */
  double m_virtualGripperAngleMin;

  //* Virtual gripper maximum angle in radians [rad]. */
  double m_virtualGripperAngleMax;

  //* Virtual speed value used for simulating the opening and closing of the
  // virtual gripper [rad/s]. */
  double m_virtualGripperAngularVelocity;

  //* Clock for computing the position/velocity of the virtual gripper. */
  std::chrono::_V2::system_clock::time_point m_tpVirtualGripperStart;

protected:
  //! Estimate linear velocity of handle by passing the latest position.
  void estimateLinearVelocity(Eigen::Vector3d& a_newPosition);

  //! Estimate angular velocity of handle by passing the latest orientation
  //! frame.
  void estimateAngularVelocity(Eigen::Matrix3d& a_newRotation);

  //! Estimate velocity of gripper by passing the latest gripper position.
  void estimateGripperVelocity(double a_newGripperPosition);

  //--------------------------------------------------------------------------
  // PROTECTED METHODS - GRIPPER USER SWITCH:
  //--------------------------------------------------------------------------

protected:
  //! This method computes the virtual gripper force.
  double computeGripperUserSwitchForce(
      const double& a_gripperAngle, const double& a_gripperAngularVelocity);

  //! This method returns the status of gripper user switch. Return __true__
  //! if virtual user switch is engaged, __false_ otherwise.
  bool getGripperUserSwitch();

  //--------------------------------------------------------------------------
  // PROTECTED METHODS - DEVICE LIBRARY INITIALIZATION:
  //--------------------------------------------------------------------------

protected:
  //! This method opens libraries for this class of devices.
  static bool openLibraries() { return true; }

  //! This method closes libraries for this class of devices.
  static bool closeLibraries() { return true; }
};

//------------------------------------------------------------------------------
} // namespace teleoperation
} // namespace flexiv

#endif